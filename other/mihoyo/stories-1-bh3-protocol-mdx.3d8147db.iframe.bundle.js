(self.webpackChunkmihoyo_doc=self.webpackChunkmihoyo_doc||[]).push([[125],{"./node_modules/@mdx-js/react/lib/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{R:()=>useMDXComponents,x:()=>MDXProvider});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");const emptyComponents={},MDXContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents);function useMDXComponents(components){const contextComponents=react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext);return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){return"function"==typeof components?components(contextComponents):{...contextComponents,...components}}),[contextComponents,components])}function MDXProvider(properties){let allComponents;return allComponents=properties.disableParentContext?"function"==typeof properties.components?properties.components(emptyComponents):properties.components||emptyComponents:useMDXComponents(properties.components),react__WEBPACK_IMPORTED_MODULE_0__.createElement(MDXContext.Provider,{value:allComponents},properties.children)}},"./src/stories/1.bh3/protocol.mdx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>MDXContent});__webpack_require__("./node_modules/next/dist/compiled/react/index.js");var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/next/dist/compiled/react/jsx-runtime.js"),C_D_work_Web_software_mihoyo_doc_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@mdx-js/react/lib/index.js"),_storybook_blocks__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@storybook/blocks/dist/index.mjs");function _createMdxContent(props){const _components={a:"a",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,C_D_work_Web_software_mihoyo_doc_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim__WEBPACK_IMPORTED_MODULE_2__.R)(),...props.components};return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_3__.W8,{title:"崩坏3/协议"}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["崩坏3的私服研究虽然并没有停止，但是由于不明势力的打击，导致开源维护者没有了，已经转入了闭源。我们就稍微学点历史经验吧，即比较老的",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.a,{href:"https://github.com/dfmjndm/PemukulPaku",rel:"nofollow",children:"PemukulPaku"}),"项目。私服的起点研究是",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.strong,{children:"通信协议"}),"，而这正是我们这部分讨论的内容。"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["崩坏3的协议定义于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Common/Resources/"}),"(命名空间加",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Proto"}),")中，我没有写错哦，因为它并没有被开源(可以使用vs自带的ildasm反编译",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Common.dll"}),")。那么我们该怎么研究，总不能重新去破解一遍吧，没事的，我们的目的是学习，能学到一点东西就足够了，既然没办法学协议，就从代码的其它部分学学服务端是如何处理各种请求的吧。因此，我们从程序的运行流程来讨论讨论吧，其位于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Program.cs"}),"中。"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.ul,{children:["\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li,{children:["首先是服务器的设置部分，其对象Global定义于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Common/Program.cs"}),"中，并使用了",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Config.Net"}),"完成默认值的设置；"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li,{children:["接着",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"CommandFactory.LoadCommandHandlers()"}),"用于加载所有服务端的指令并保存到成员变量",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"Commands"}),"中，使用了C#的反射机制，加载带有属性",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"CommandHandler"}),"的类，其大多定义于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer/Commands/"}),"中；紧接着的",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"PacketFactory.LoadPacketHandlers()"}),"也是类似的，但这个用于加载客户端发送来的指令，其大多定义于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer/Handlers/"}),"中；"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.li,{children:["然后会开启一个http/https服务器(位于模块",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"HttpServer"}),"中)和一个tcp服务器(",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer"}),"的主要部分，起始于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer/Server.cs"}),")，这两个服务器用于处理两类不同的任务，mihoyo系诸如登入、下载之类的公共部分由http/https进行处理(你也可以用浏览器看看)，而游戏的部分则由tcp处理；"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.li,{children:"最后两个便于你在服务端命令行输入指令用的，不用管。"}),"\n"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["崩坏3的一键端中有一个mitmproxy代理服务器，其就是用于拦截转发http/https类请求用的，在崩坏3的一键端中还有一个phpstudy，其会启动一个Nginx在80端口，作用是资源下载的服务器代理(过程在",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"HttpServer/Controllers/DispatchController.cs"}),"中)，搞这么麻烦确实有些不明所以。另外，我们并没有发现tcp协议(http/https？)的转发部分，实际上由于我下载得比较晚，游戏会卡在更新客户端的界面，其正是使用tcp协议(mitmweb抓包不到)，导致我完全无法使用，只能说一键端的可用性存疑，可能需要通过特定的修改过的客户端实现转发。"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["我们就假装它代理成功了吧，游戏的登录响应在",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"HttpServer/Controllers/AccountController.cs"}),"中，无论怎么输入都会给你创建一个账号并创建Token用于游戏连接，真正的多人私服应该会有更复杂的机制，其它的信息就别管理。此时客户端大概已经登入，与我们的GameServer进行交互，当收到连接的时候，服务器会创建一个Session(定义于",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer/Session.cs"}),")并保存TcpClient引用来表示客户端。这玩意会启动两个线程，",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"ClientLoop"}),"用于接收数据，",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"KeepAliveLoop"}),"用于确保还处于连接中。后者没啥好说的，在接收数据循环中采用的是循环同步读取，其会截取二进制数据",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"0x01234567"}),"至",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"0x89ABCDEF"}),"之间(包含自己)的数据，这大概就是蕴含在tcp数据中的核心协议数据了，其它部分大概是不重要的。"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["整个协议数据通过",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"GameServer/Packet.cs"}),"进行定义(？这只是一层壳而已，懂？)从解包过程可以知道，其解析得并不完全，但是深得精髓。",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"24-28"}),"为CmdId，虽然没开源但显然就是客户端指令编号的意思，包似乎分为header和body两部分，但程序只解析保留了body部分，看样子其它的东西不是很重要，简单拆包以后，回到Session后其调用",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"ProcessPacket"}),"进行处理。首先获得枚举类CmdId对应的名称，当然我们没有源码，然后判断这名称有没有相应的处理，有的话就用我们之前注册的handler进行处理。此时或许你会觉得难道只有一个CmdId没开源吗？这是错误的哦，因为在这些处理函数中用到了大量其命名空间中的类，随便一翻就是一大堆，诸如AddAvatarExpByMaterialReq、GetEquipmentDataRsp、AddGoodfeelReq等等。"]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(_components.p,{children:["实际上我们发现崩坏3的大部分指令都只是获得一些需要服务端更新的数据或是上传一些数据，因此崩坏3大部分的游玩过程都不会有太多问题，这还算是比较良心的了。在下一个游戏中，你会发现什么是痛苦，连伤害计算都在云端进行，多少有些大病。好了，感觉崩坏3也没啥可讲的了，就到此为止了吧，哦，对了如果想看开发者的寄语，就用浏览器打开",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{children:"localhost:80"}),"。"]})]})}function MDXContent(props={}){const{wrapper:MDXLayout}={...(0,C_D_work_Web_software_mihoyo_doc_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim__WEBPACK_IMPORTED_MODULE_2__.R)(),...props.components};return MDXLayout?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MDXLayout,{...props,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_createMdxContent,{...props})}):_createMdxContent(props)}},"./node_modules/memoizerific sync recursive":module=>{function webpackEmptyContext(req){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}webpackEmptyContext.keys=()=>[],webpackEmptyContext.resolve=webpackEmptyContext,webpackEmptyContext.id="./node_modules/memoizerific sync recursive",module.exports=webpackEmptyContext},"./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var f=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function p(c,a,g){var b,d={},e=null,h=null;for(b in void 0!==g&&(e=""+g),void 0!==a.key&&(e=""+a.key),void 0!==a.ref&&(h=a.ref),a)m.call(a,b)&&"key"!==b&&"ref"!==b&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l,exports.jsx=p,exports.jsxs=p},"./node_modules/next/dist/compiled/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js")}}]);