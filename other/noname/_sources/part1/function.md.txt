# 联机函数

前面我们对无名杀联机的框架，进行了十分详细的解读，但我知道通过文字描述，读者已经十分迷糊了，因此我们将对模型进行简化，以达到便于理解的目的。

## 简化模型

无名杀的联机过程为一次game，最开始的game模式为connect，当我们连接进服务器的时候，处于第一类状态即“大厅等待状态”，此时我们主要与服务器交互，可以执行进入房间、创建房间等操作。而数据交互的方式为json数组，其第一个元素表示执行的函数，后面参数为执行函数的参数，在客户端对应`lib.message.client`，在服务端对应`message`。

当进入房间时，我们成为玩家，并将模式切换为房主的游戏模式，此时处于第二类状态即“玩家状态”，此时本地向服务器发送的指令数据，转化为执行房主的`lib.message.server`下的函数。

当创建房间时，我们成为房主，并将模式切换为对应游戏模式，此时处于第三类状态即“房主状态”，本地将建立一个服务器和连入用户的信息数组，并令服务器充当中转站。

## 相关API

在上述简化模型之下，我们讲一下游戏的一些主要联机API。

`game.send`向服务器发送数据。处于状态一时，即执行服务器`message`下的函数；处于状态二时，即执行房主`lib.message.server`中的函数；处于状态三时，与状态一是一样的，如果想要输出数据到连接到的用户，则房主应执行服务端的send函数。

`this.send`此方法只能在房主的`lib.message.server`下执行，this指向调用这个函数的连接玩家，其通过服务器中转向这个玩家发送指令数据，其执行玩家`lib.message.client`下的函数。

`game.players[i].send`其实就是上一个函数，但从固定的函数中解脱了出来，只有房主能执行，i表示哪个玩家。

`game.broadcast()`只有房主执行了才有作用，是send的简化，表示向所有的玩家执行send。

然后剩下的东西，虽然也与联机相关，但相当于内部的东西，不去搞它才是最好的。其实大多数时候，发送数据的责任主要还是在房主这一边，而执行的内容一般都是函数回调，用于各种数据的更新。