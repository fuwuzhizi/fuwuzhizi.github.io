<!doctype html>
<html class="no-js" lang="zh-cn" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="next" title="游戏开始" href="start.html" /><link rel="prev" title="运行流程" href="process.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>C/S架构 - QT系杀文档 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">QT系杀文档  文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">QT系杀文档  文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">快速入门</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">游戏运行原理</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">神杀-v2</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 神杀-v2</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="process.html">运行流程</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">C/S架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="start.html">游戏开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="luaScript.html">lua脚本</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../part2/index.html">新月杀</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="c-s">
<h1>C/S架构<a class="headerlink" href="#c-s" title="Link to this heading">#</a></h1>
<p>所谓的C/S架构实际上就是两个对象直接互相传递信息的过程，核心方法无非就是“发送数据信息”和“信息接收的监听”，因此我们主要探究Client和Server的这两个部分。</p>
<section id="id1">
<h2>服务器<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>服务器的实现为QTcpServer，保存于成员变量server中，当一个用户进行连接请求的时候，会触发信号<code class="docutils literal notranslate"><span class="pre">newConnection</span></code>，Server通过Qt的“信号-槽”机制将其重定向为<code class="docutils literal notranslate"><span class="pre">processNewConnection</span></code>。在处理的函数中，先通过<code class="docutils literal notranslate"><span class="pre">nextPendingConnection</span></code>将连接的QTcpSocket对象取出，并实例化成与接口无关的ClientSocket对象，最后将这个对象作为参数触发<code class="docutils literal notranslate"><span class="pre">new_connection</span></code>信号。回到Server对象初始化的过程中，其有两个核心内容，一个是调用<code class="docutils literal notranslate"><span class="pre">createNewRoom()</span></code>来创建房间。</p>
<ul class="simple">
<li><p>首先，根据<code class="docutils literal notranslate"><span class="pre">Config.GameMode</span></code>中的游戏模式，创建Room对象(定义于<code class="docutils literal notranslate"><span class="pre">src/server/room.cpp</span></code>中)。而房间主要就是初始化各种数据，比如获取玩家数量，获取模式的scenario，此处的模式除了剧情模式和小型场景以外，玩家通过进入时的配置界面得到的模式属于custom_scenario，保存在Sanguosha的m_customScene对象里，是CustomScenario的实例化，和小型场景的LoadedScenario一样，均属于MiniScene的子类；</p></li>
<li><p>接着是lua环境的检测，在房间创建的时候会被初始化，并加载<code class="docutils literal notranslate"><span class="pre">lua/sanguosha.lua</span></code>和<code class="docutils literal notranslate"><span class="pre">lua/ai/smart-ai.lua</span></code>。值得注意的是，这和Sanguosha里的lua环境是不同的，这个是属于服务器Server的，用于建立整个游戏的运行逻辑，因此它并没有读入用于客户端相关设置的<code class="docutils literal notranslate"><span class="pre">config.lua</span></code>；</p></li>
<li><p>最后是房间插入房间列表，并进行相关的“信号-槽”绑定，简单来说就是把房间的信号发送到Server对象，并通过Server对象来便于发送给每个客户端。</p></li>
</ul>
<p>另一个核心则是对<code class="docutils literal notranslate"><span class="pre">new_connection</span></code>又进行了一次重定向，只不过这次带了个ClientSocket对象，处理过程在函数<code class="docutils literal notranslate"><span class="pre">processNewConnection</span></code>中。</p>
<ul class="simple">
<li><p>首先，服务器会取出地址，看其是否是被ban掉的IP，是的话就通过<code class="docutils literal notranslate"><span class="pre">disconnectFromHost()</span></code>直接让它滚蛋。至于此处的server_message信号只是用于记录服务器的日志，如果以服务器状态启动的话就会和StartScene的server_log的UI关联起来；</p></li>
<li><p>然后监听客户端的断开信号，将其关联到<code class="docutils literal notranslate"><span class="pre">cleanup</span></code>函数，只是清除ClientSocket对象和玩家数量来减少内存占用而已。然后发了两个数据包到客户端，此处的数据包是神杀自定的一种协议(定义于<code class="docutils literal notranslate"><span class="pre">src/core/protocol.cpp</span></code>)，是一种指令式协议，后面我们再详细讨论。一个是版本检测checkVersion，通过这个客户端成功进入了房间，另一个是设置setup，总之就是成功入房后想干啥就干啥；</p></li>
<li><p>最后将这个客户端的message_got信号连接到processRequest进行处理。这个信号来自于ClientSocket底层实现的getMessage函数，当服务端从客户端收到以<code class="docutils literal notranslate"><span class="pre">\n</span></code>结束的一行数据后，触发此信号让服务端进行处理。</p></li>
</ul>
<p>看完连接事件，断开没啥好看的，于是正好来看看接收信号后的处理事件。</p>
<ul class="simple">
<li><p>首先通过<code class="docutils literal notranslate"><span class="pre">sender()</span></code>获得信号的发送者，也就是在服务端的对应客户端的ClientSocket对象，然后暂时断开信号连接，先处理完当前的数据包后再恢复；</p></li>
<li><p>然后通过Packet对象，即我们的神杀协议，对数据包进行匹配解析，如果数据包不符合协议，则向客户端发送警告信息并断开连接；</p></li>
<li><p>接着从数据包中可以解析出，名称和头像等信息，并且查看当前是重连、创建房间、还是加入游戏。创建房间的过程，我们已经见识过了，所以不论重连还是加入，主要还是进入这个动作；</p></li>
<li><p>此时在服务器中，客户端将从普通的ClientSocket对象，转化为ServerPlayer对象，对于重连的玩家会直接从服务器的players进行寻找，而服务器玩家对象创建的过程在<code class="docutils literal notranslate"><span class="pre">addSocket</span></code>函数中。</p></li>
</ul>
<p>没想到吧，服务器的连接还分为两层，最开始的连接是普通的ClientSocket，发送名称头像等信息后，就会升级为ServerPlayer对象(定义于<code class="docutils literal notranslate"><span class="pre">src/server/serverplayer.cpp</span></code>)，我们来看看它的创建过程。</p>
<ul class="simple">
<li><p>首先，我们会创建一个ServerPlayer，并将通信组件设置为原来的ClientSocket，具体来说就是就是信号的重定向。将收到信息的message_got信号交给升级对象的<code class="docutils literal notranslate"><span class="pre">getMessage</span></code>进行处理；</p></li>
<li><p>接着又是两个信号连接，断开不用管，主要是其将request_got与服务端的<code class="docutils literal notranslate"><span class="pre">processClientPacket</span></code>进行连接，而request_got实际上就是升级对象的<code class="docutils literal notranslate"><span class="pre">getMessage</span></code>进行处理时发出的信号，也就是说接收的数据在升级后由服务器房间的<code class="docutils literal notranslate"><span class="pre">processClientPacket</span></code>函数进行处理；</p></li>
<li><p>最后，服务其通过<code class="docutils literal notranslate"><span class="pre">signup</span></code>为玩家注册信息，并发出newPlayer信号表示来了一个玩家。注册就是将信息保存到房间中，并向包括房主的玩家展示某些东西，而newPlayer信号主要发给相关的UI，用于更新信息。</p></li>
</ul>
<p>兜兜转转以后，为了了解服务器对收到信息的处理，我们又要转向processClientPacket函数。</p>
<ul class="simple">
<li><p>首先依旧是通过Packet进行解包，并获得发送的ServerPlayer对象；</p></li>
<li><p>接着查看游戏是否结束，结束的话，向这个玩家发送游戏已经结束的警告信息；</p></li>
<li><p>接着判断数据包的类型，如果是REPLY型，表示这是玩家对服务器的响应数据，通过<code class="docutils literal notranslate"><span class="pre">processResponse</span></code>函数进行处理。在处理过程中，会有是否为回应状态检测、回应格式是否正确检测等，成功通过以后，里面有各种互斥锁的操作，主要就是多线程数据保护用的，而所谓的响应也就只是通过setClientReply改变了玩家对象的一段数据。这类信息实际就是，当游戏进行某些需要玩家操作的内容的时候，会做出请求，玩家操作完结以后，服务器就会受到这类反馈数据；</p></li>
<li><p>最后判断的数据类型为REQUEST型和NOTIFICATION型，它们均由玩家主动发出，其内容是调用服务器房间m_callbacks中存储的函数指针，其在房间创建的时候就已经通过<code class="docutils literal notranslate"><span class="pre">initCallbacks()</span></code>函数被初始化了。</p></li>
</ul>
<p>由于神杀采用的为TCP协议，为字节流传输的协议，所以对于一段数据会经过多层的包装，搞清这些协议的内容是搞清神杀交互机制的基础。</p>
</section>
<section id="id2">
<h2>客户端<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>我们再来看看客户端吧，在神杀中单机启动和连入服务器的本质其实是一样的，只是前者会在本地启动服务器。客户端的实现只需要一个QTcpSocket，其被套上了NativeClientSocket的壳用于本地实现，并最后封装到Client屏蔽差异。但无论如何我们只关注连接事件和信息接收事件。</p>
<ul class="simple">
<li><p>连接函数<code class="docutils literal notranslate"><span class="pre">connectToHost</span></code>在创建Client时被调用，连接成功后会触发<code class="docutils literal notranslate"><span class="pre">connected</span></code>信号，但游戏并没有处理，也就是发送连接信号，连上以后就是等待服务器的反馈了；</p></li>
<li><p>由之前可知，我们会收到服务器发出的两个数据包，因此我们先来查看一下客户端接收数据的处理过程；</p>
<ul>
<li><p>收到数据的信号为<code class="docutils literal notranslate"><span class="pre">readyRead</span></code>，其先被绑定到了NativeClientSocket的<code class="docutils literal notranslate"><span class="pre">getMessage</span></code>函数上，其会读取一行数据，并发送信号message_got将数据携带过去；</p></li>
<li><p>在客户端创建过程中，将message_got分别绑定到了录像机和<code class="docutils literal notranslate"><span class="pre">processServerPacket</span></code>函数上，我们需要考察的是后者；</p></li>
<li><p>处理的过程与服务器类似，通过Packet进行协议解包，对于NOTIFICATION型数据，直接调用m_callbacks中对应的函数指针来处理；</p></li>
<li><p>而对于REQUEST型数据，进行另一层解包后，调用m_interactions中对应的函数指针来处理。</p></li>
</ul>
</li>
<li><p>服务器发送的<code class="docutils literal notranslate"><span class="pre">S_COMMAND_CHECK_VERSION</span></code>为NOTIFICATION型数据，因此调用<code class="docutils literal notranslate"> <span class="pre">m_callbacks[S_COMMAND_CHECK_VERSION]</span> <span class="pre">=</span> <span class="pre">&amp;Client::checkVersion;</span></code>，即<code class="docutils literal notranslate"><span class="pre">checkVersion</span></code>函数；</p></li>
<li><p>进行简单的数据处理拆分之后，发出version_checked的信号，这个信号又被绑定到了MainWindow的<code class="docutils literal notranslate"><span class="pre">checkVersion</span></code>函数，这就和我们之前说的完全一样；</p></li>
<li><p>在注册函数<code class="docutils literal notranslate"><span class="pre">sign()</span></code>函数中，我们向服务器发送NOTIFICATION型的数据S_COMMAND_SIGNUP，但此时服务器处于ClientSocket阶段使用<code class="docutils literal notranslate"><span class="pre">processRequest</span></code>进行处理，而这类信息只是为了能通过前面的检测而升级为ServerPlayer对象，从而完成所谓的注册；</p></li>
<li><p>然后服务器的第二个数据包是NOTIFICATION型的<code class="docutils literal notranslate"><span class="pre">S_COMMAND_SETUP</span></code>，即客服端调用<code class="docutils literal notranslate"><span class="pre">setup</span></code>函数，进行一些处理后，客户端先发出server_connected的信号，其在MainWindow中被绑定到了enterRoom函数上，于是又回到了上一部分的内容，也就是相关UI界面的更新；</p></li>
<li><p>本地界面搞好后，本地会再次向服务端发送NOTIFICATION型的数据S_COMMAND_TOGGLE_READY，此时服务端为ServerPlayer阶段，因此即调用服务端房间的<code class="docutils literal notranslate"><span class="pre">toggleReadyCommand</span></code>函数；</p></li>
<li><p>而这个函数的内容就是我们之前所说的，如果游戏未开始且人满了，就调用<code class="docutils literal notranslate"><span class="pre">start()</span></code>开始游戏。</p></li>
</ul>
<p>客户端的内容显然并不复杂。</p>
</section>
<section id="id3">
<h2>传输协议<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>为了更好地讲解游戏的运行过程，我们需要先研究一下，神杀的传输协议，实际上在前面我们已经见过好多次了，其本质就是一种指令的互传。翻开协议的定义文件<code class="docutils literal notranslate"><span class="pre">src/core/protocol.h</span></code>，枚举部分可以直接跳过了，我们直奔Packet类，其继承自抽象类AbstractPacket，但并没有多态，所以不看也无所谓。</p>
<p>由于其书写并不规范，所以我们从数据的创建过程进行考察，即构造方法<code class="docutils literal notranslate"><span class="pre">Packet</span> <span class="pre">packet(S_SRC_ROOM</span> <span class="pre">|</span> <span class="pre">S_TYPE_NOTIFICATION</span> <span class="pre">|</span> <span class="pre">S_DEST_CLIENT,</span> <span class="pre">S_COMMAND_CHECK_VERSION);</span></code>，其第一部分为包描述存储于packetDescription中，其占1.5个字节，每0.5个字节分别代表[目的地，出发地，类型]，每个字节以“位1指示”的方式说明类型。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">PacketDescription</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">S_DESC_UNKNOWN</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_TYPE_REQUEST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_TYPE_REPLY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x2</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_TYPE_NOTIFICATION</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x4</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_TYPE_MASK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_SRC_ROOM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x10</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_SRC_LOBBY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_SRC_CLIENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x40</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_SRC_MASK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf0</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_DEST_ROOM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x100</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_DEST_LOBBY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x200</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_DEST_CLIENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x400</span><span class="p">,</span>
<span class="w">    </span><span class="n">S_DEST_MASK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf00</span><span class="p">,</span>

<span class="w">    </span><span class="n">S_DESC_DUMMY</span>
<span class="p">};</span>
</pre></div>
</div>
<blockquote>
<div><p>位1指示：因为不知道怎么称呼而乱起的名字，简单来讲就是在二进制位中通过特定位置为1，其它位置为0来表示类型的方法。在此例中，<code class="docutils literal notranslate"><span class="pre">0x1=01</span></code>、<code class="docutils literal notranslate"><span class="pre">0x2=010</span></code>、<code class="docutils literal notranslate"><span class="pre">0x4=0100</span></code>、<code class="docutils literal notranslate"><span class="pre">0xf=01000</span></code>就分别代表了四种数据类型。至于为什么这么做，至少有减少数据传输流量这一回事。</p>
</div></blockquote>
<p>其第二部分为指令，直接被赋值给了成员变量command，显然此时的包体并不完全，我们还需通过<code class="docutils literal notranslate"><span class="pre">setMessageBody</span></code>来完善传输使用的数据，其将游戏版本号赋值给了messageBody。而此时包体就已经构建完成了，但它无法用于字节流的传输，所以我们调用<code class="docutils literal notranslate"><span class="pre">toString</span></code>的方法让对象结构化，过程实现就是类数据的Json化，大家搞数据传输似乎都喜欢这一套呢！</p>
<p>当然当然单纯Json化还不够，还得再byte化，再编码统一化。QString对象只是为了放到send的参数中，为了让数据只用一行的byte类型的发送出去，还需调用QString的<code class="docutils literal notranslate"><span class="pre">toLatin1</span></code>处理一下，即ASCII化。接收时，我们会使用<code class="docutils literal notranslate"><span class="pre">parse</span></code>来解析二进制数据，过程就是倒过来，从而得到Packet对象。实际上，底层的东西看看就好，而应用层的东西并不多。</p>
<p>我们需要注意的是messageBody为QVariant类型，而不单单是一个字符串类型，其是可以用来存储函数调用参数的。在服务器发送setup指令的时候就调用<code class="docutils literal notranslate"><span class="pre">Sanguosha-&gt;getSetupString()</span></code>获取游戏设置，并将其作为包体内容进行发送。另外，我们不要因为看到包体结构简单就觉得信息交流会少很多，实际上我们可以通过结构化messageBody的嵌套得到更多的东西。</p>
<p>在具体的指令函数方面，客户端的显然十分简单，定义在Client的构造函数中，并且都是直接进行绑定的。而服务器这边就有些复杂了，从ClientSocket向ServerPlayer的升级过程已经探究过了，核心的内容主要集中在Server的Room对象中，REPLY与游戏进行相关我们后面再说，而m_callbacks的指令尽然只有8个，是不是有点太少了。</p>
<p>随便看看名字，<code class="docutils literal notranslate"><span class="pre">toggleReadyCommand</span></code>是玩家准备就绪后触发，<code class="docutils literal notranslate"><span class="pre">addRobotCommand</span></code>显然是加机器人，<code class="docutils literal notranslate"><span class="pre">speakCommand</span></code>是发送聊天信息，<code class="docutils literal notranslate"><span class="pre">trustCommand</span></code>改变状态，<code class="docutils literal notranslate"><span class="pre">pauseCommand</span></code>暂停游戏，<code class="docutils literal notranslate"><span class="pre">networkDelayTestCommand</span></code>用于延时测试，<code class="docutils literal notranslate"><span class="pre">processRequestCheat</span></code>用于处理作弊请求，<code class="docutils literal notranslate"><span class="pre">processRequestSurrender</span></code>用于处理投降请求。嗯，确实都是房间相关，没有游戏的感觉，为此，我们还是来看看游戏的运行过程吧。</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="start.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">游戏开始</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="process.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">运行流程</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, fuwuzhizi
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">C/S架构</a><ul>
<li><a class="reference internal" href="#id1">服务器</a></li>
<li><a class="reference internal" href="#id2">客户端</a></li>
<li><a class="reference internal" href="#id3">传输协议</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=ab3e9284"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=32e29ea5"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    </body>
</html>